// TODO
// better solutions ???
// code optimize ???
// the answer is limit to A[0] or B[0]
// find better way to do this
int minDominoRotations(int* A, int ASize, int* B, int BSize)
{
    int a = 0;
    int b = 0;
    for (int i = )
    /* int u[6] = {0}; */
    /* int d[6] = {0}; */
    /* int si = 0; */
    /* int sn = 0; */
    /* int fs = 6; */
    /* int f[6] = {0}; */
    /* int all[6] = {0}; */
    /* for (int i = 0; i < ASize; i ++) */
    /* { */
    /*     int a = A[i]; */
    /*     int b = B[i]; */
    /*     all[a - 1] ++; */
    /*     all[b - 1] ++; */
    /*     if (a != b) */
    /*     { */
    /*         u[a - 1] ++; */
    /*         d[b - 1] ++; */
    /*     } */
    /*     else */
    /*     { */
    /*         if (!si) */
    /*             si = a; */
    /*         else if (si != a) */
    /*             return -1; */
    /*         sn ++; */
    /*     } *

    /*     if (all[a - 1] < i + 1) */
    /*     { */
    /*         if (!f[a - 1]) */
    /*         { */
    /*             f[a - 1] = 1; */
    /*             fs --; */
    /*         } */
    /*     } */

    /*     if (all[b - 1] < i + 1) */
    /*     { */
    /*         if (!f[b - 1]) */
    /*         { */
    /*             f[b - 1] = 1; */
    /*             fs --; */
    /*         } */
    /*     } */
    /*     if (!fs) */
    /*         return -1; */
    /* } */

    /* if (si) */
    /* { */
    /*     if (u[si - 1] + d[si - 1] + sn != ASize) */
    /*         return -1; */
    /*     return u[si - 1] < d[si - 1] ? u[si - 1] : d[si - 1]; */
    /* } */

    /* int min = INT_MAX; */
    /* for (int i = 0; i < 6; i ++) */
    /* { */
    /*     if (u[i] + d[i] < ASize) */
    /*         continue; */
    /*     min = min > u[i] ? u[i] : min; */
    /*     min = min > d[i] ? d[i] : min; */
    /* } */
    /* return min == INT_MAX ? -1 : min; */
}
